
extern fn malloc(i32 size) -> void*
extern fn free(void* ptr) -> void*
extern fn memcpy(void* dest, void* src, i32 size) -> void*

extern fn fopen(char* filename, char *mode) -> void*
extern fn fclose(void* stream) -> i32
extern fn fputs(char* str, void* stream) -> i32
extern fn fgets(char* str, i32 num, void* stream) -> char*

fn AllocateString(i32 length)
{
    return (char*)malloc(length + 1)
}

fn CopyString(char* dest, char* src, i32 length)
{
    memcpy((void*)dest, (void*)src, length)
    dest[length] = '\0'
}

fn Free(void* ptr)
{
    free(ptr)
}

fn StrLen(char* str)
{
    i32 len = 0
    while (str[len] != '\0')
    {
        len = len + 1
    }
    return len
}

type String
{
    i32 length
    char* data

    new(char* str)
    {
        length = StrLen(str)
        data = AllocateString(length)
        CopyString(data, str, length)
    }

    fn Concat(String other)
    {
        i32 newLength = length + other.length
        char* newData = AllocateString(newLength)
        CopyString(newData, data, length)
        CopyString(newData + length, other.data, other.length)
        return new String(newData)
    }
}

type File
{
    String filename
    bool isOpen
    bool canRead
    bool canWrite
    void* handle

    new(char* filename)
    {
        this.filename = new String(filename)
        this.isOpen = false
        this.canRead = false
        this.canWrite = false
    }

    fn OpenReadOnly()
    {
        if (isOpen)
        {
            Print("File already open.\n")
            return
        }

        handle = fopen(filename.data, "r")
        isOpen = true
        canRead = true
        canWrite = false
    }

    fn OpenWriteOnly(bool append)
    {
        if (isOpen)
        {
            Print("File already open.\n")
            return
        }
        
        if (append)
        {
            handle = fopen(filename.data, "a")
        }
        else
        {
            handle = fopen(filename.data, "w")
        }

        isOpen = true
        canRead = false
        canWrite = true
    }

    fn OpenReadWrite(bool append)
    {
        if (isOpen)
        {
            Print("File already open.\n")
            return
        }

        if (append)
        {
            handle = fopen(filename.data, "a+")
        }
        else
        {
            handle = fopen(filename.data, "w+")
        }

        isOpen = true
        canRead = true
        canWrite = true
    }

    fn Write(char* content)
    {
        if (!isOpen || !canWrite)
        {
            Print("File not open for writing.\n")
            return
        }

        fputs(content, handle)
    }

    fn Read()
    {
        if (!isOpen || !canRead)
        {
            Print("File not open for reading.\n")
            return new String("")
        }

        var str = new String("")

        char* buffer = AllocateString(1024)
        while (fgets(buffer, 1024, handle) != (char*)0)
        {
            str = str.Concat(new String(buffer))
        }
        Free((void*)buffer)
        return str
    }

    fn Close()
    {
        if (!isOpen)
        {
            return
        }

        fclose(handle)
    }
}

fn PrintStr(String str)
{
    Print(str.data)
}

fn Main
{
    var hello = new String("Hello, ")
    var world = new String("Fern!\n")
    var greeting = hello.Concat(world)
    var file = new File("greeting.txt")
    file.OpenReadWrite(true)
    var f = file.Read()
    PrintStr(f)
    file.Write(greeting.data)
    file.Close()
    return 0.0
}
