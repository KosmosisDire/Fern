
extern fn fopen(char* filename, char *mode) -> void*
extern fn fclose(void* stream) -> i32
extern fn fputs(char* str, void* stream) -> i32
extern fn fgets(char* str, i32 num, void* stream) -> char*


type File
{
    String filename
    bool isOpen
    bool canRead
    bool canWrite
    void* handle

    new(char* filename)
    {
        this.filename = new String(filename)
        this.isOpen = false
        this.canRead = false
        this.canWrite = false
    }

    fn OpenReadOnly()
    {
        if (isOpen)
        {
            Print("File already open.\n")
            return
        }

        handle = fopen(filename.data, "r")
        isOpen = true
        canRead = true
        canWrite = false
    }

    fn OpenWriteOnly(bool append)
    {
        if (isOpen)
        {
            Print("File already open.\n")
            return
        }
        
        if (append)
        {
            handle = fopen(filename.data, "a")
        }
        else
        {
            handle = fopen(filename.data, "w")
        }

        isOpen = true
        canRead = false
        canWrite = true
    }

    fn OpenReadWrite(bool append)
    {
        if (isOpen)
        {
            Print("File already open.\n")
            return
        }

        if (append)
        {
            handle = fopen(filename.data, "a+")
        }
        else
        {
            handle = fopen(filename.data, "w+")
        }

        isOpen = true
        canRead = true
        canWrite = true
    }

    fn Write(char* content)
    {
        if (!isOpen || !canWrite)
        {
            Print("File not open for writing.\n")
            return
        }

        fputs(content, handle)
    }

    fn Read()
    {
        if (!isOpen || !canRead)
        {
            Print("File not open for reading.\n")
            return new String("")
        }

        var str = new String("")

        char* buffer = AllocateString(1024)
        while (fgets(buffer, 1024, handle) != (char*)0)
        {
            str = str.Concat(new String(buffer))
        }
        Free((void*)buffer)
        return str
    }

    fn Close()
    {
        if (!isOpen)
        {
            return
        }

        fclose(handle)
    }
}
